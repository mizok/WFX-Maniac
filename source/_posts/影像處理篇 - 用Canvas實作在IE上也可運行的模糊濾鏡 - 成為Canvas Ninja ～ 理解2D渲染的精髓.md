---
title: Day 25 - 影像處理篇 - 用Canvas實作在IE上也可運行的模糊濾鏡I - 成為Canvas Ninja ～ 理解2D渲染的精髓
categories: 
- 前端技術學習心得
tags:
- 2021鐵人賽
---

在這一篇我們要來講一些比較進階的內容。

那就是圖像模糊演算法～

應該大部分有Debug過IE的人都知道，IE是不支援css的filter屬性的。

但是很多時候設計師交上來的稿子裡面又會含有很多的模糊特效。

通常這種時候大部分的工程師都會自己取捨要不要實現這樣的Feature，   

本文的主旨就是提供各位一個備選方案~ 也就是用canvas來實作模糊特效。

這篇文一共會分成兩篇來講解，第一篇我們會進行`理論`面的講解，而第二篇才會進入`實作`。


# 從像素觀點來看所謂的模糊

![img](https://i.imgur.com/HKfDRBb.jpg)

不知道大家還對小時後的`考試成績`結算的方法有沒有印象～

例如小時候老師在月考前會說：『這次月考的成績統計會採`加權制度`，數學的加權`權重`會是3, 國/英文是2，社會/自然是1』

老師這樣講的意思就是說～最後平均成績的計算方式會是：  

『(數學分數\*3+國文分數\*2+英文分數\*2+社會分數\*1+自然分數\*1) / (3+2+2+1+1)』

像這樣的分數計算，就是一種`加權運算`。

而我們在這邊要提到的`模糊`說穿了其實也就是一種`加權運算`。

為什麼這樣說呢? 我們先來看看最簡單的`圖形模糊演算法`: `方框模糊(Box Blur)`的做法～

![img](https://i.imgur.com/0C4bKI5.png)

> 這張照片右半部就是圖像透過方框模糊運算之後產生的結果

熟悉`Photoshop`操作的人一定知道，`模糊`其實有分成很多種類，除了我們現在提到的`方框模糊(Box Blur)`以外，還有`動態模糊(Motion Blur)`, `高斯模糊(Gaussian Blur)`...,etc.

這幾種模糊的差別其實就在於背後實現它們的`加權運算`的`權重`不太一樣。

以 `方框模糊(Box Blur)`來講， 它的`加權運算`是取`每顆像素(這邊先把它叫做像素i)`的n宮格(九宮格是3*3, 那n宮格就是√n *√n)範圍內的鄰近像素(包括自己)

每顆像素的權重都定為1，最後把這些像素加起來取平均(也就是把他們的`r/g/b/a`值統統個別的加起來，然後不做任何權重加成來取平均), 最後把這個平均賦予給`像素i`，像這樣的動作去把`每個像素`都處理一遍，就會變成我們上面看到的圖樣。

> 如果光看文字還是不懂意思，可以看下面這張圖

![img](https://i.imgur.com/DxdCZ1D.png)

在上面這張圖我們可以看到`n宮格`範圍內的`r/g/b值`都分別被取了平均，然後賦予到`n宮格`中間的像素上面。  

這個就是`方框模糊(Box Blur)`的做法。  

# 模糊與卷積核

我們剛剛提到的『n宮格，而且每一格的權重都只有1』，像這樣的一個Pattern，我們先姑且把它稱為`像素加權模型`，我們可以用一個陣列來表示之：

````javascript
[
  1,1,1
  1,1,1
  1,1,1
]
````

像這樣的`像素加權模型`其實有一個正式的名稱，那就是`Convolution kernel(卷積核)`。

`模糊`之所以會有不同的類型，主要原因就是`卷積核`的不同。

例如以`高斯模糊`為例，高斯模糊的`卷積核`，以大小3\*3/5\*5/7\*7的情況來看，大致上個別是這樣:

![img](https://i.imgur.com/ha7Z3mI.png)

我們這邊把這樣子的`卷積核`做成3D模型來看，就看起來會像`鐘型分佈`

![img](https://i.imgur.com/N5acUPp.jpg)


這個就是圖像模糊運算的`經典理論`。


# 經典與實作的差別

我們剛剛提到了圖像模糊運算的`經典理論`，BUT 實際上我們在`前端`如果要實現如同`理論`中描述的運算的話，我們來看看會發生什麼事～

先假設今天我們的`卷積核`大小是3*3, 然後圖像是一張`500*500`的png;

````javascript

for (圖像中的每一顆像素 i ){
  let 總和 = 0
  let 權重總計 = 0
  for (i 的 九宮格範圍內所有像素中的某一個顆 j ){
  總和 += j* 九宮格上面 j位置 的權重
  權重總計 += 九宮格上面 j位置 的權重
  }
  let 平均= 總和/權重總計
  
}
````

這樣去計算起來，我們做這個運算至少需要跑`500`\*`500`\*`3`\*`3` = `2250000` 次迴圈才做得完`一張圖片`的圖像模糊運算。

嚇到了吧~，可以試著想像一下我們親愛的使用者打開你那放了`100張`圖片的網頁的狀況XD。

上述的這個狀況意味著如果我們照著書上的理論去實作大尺度的模糊濾鏡，肯定是會`GG`的。

> 那麼應該怎麼辦呢?



我們需要做的事情簡單來說就是`簡化理論`，例如最常見的解法就是把`n宮格`簡化成`n十字`，也就是先做一次`橫向`範圍√n格內的的`加權平均`，然後再做一次`縱向`範圍√n格內的的`加權平均`，這麼一來運算的狀況就會變成

````javascript
for (圖像中的每一顆像素 i ){
  let 總和 = 0
  let 權重總計 = 0
  for (i 的 橫向範圍√n格內所有像素中的某一顆 j ){
    總和 += j* 九宮格上面 j位置 的權重
    權重總計 += 九宮格上面 j位置 的權重
  }
  let 平均= 總和/權重總計
  總和 = 0
  權重總計 = 0
  for (i 的 橫向範圍√n格內所有像素中的某一顆 j ){
    總和 += j* 九宮格上面 j位置 的權重
    權重總計 += 九宮格上面 j位置 的權重
  }
}
````

用剛剛的情況來看(`卷積核`大小是3*3, 然後圖像是一張`500*500`的png), 迴圈次數就變成了`500`\*`500`\*(`3`+`3`) = `1500000`

直接減少了`750000`次~  

你以為就這樣結束了嗎？還沒完呢～

除了變成`十字`的操作以外，如果我們只是要實作`方框模糊`，我們其實也可以在`橫列`和`縱列`的加權運算上面做文章。

![img](https://i.imgur.com/ViiX2PK.png)

仔細的查看上圖中的像素，我們其實可以發現，如果我們已經計算完第一顆像素的`平均值`的話(這邊講平均是因為我們是做方框模糊)，那麼下一顆像素的`平均`其實就等於：

````
((這一組卷積核的像素值總和) - (這一組卷積核的第一顆像素值) + (下一組卷積核的最後一顆像素值) ) / 卷積核寬度
````

這個算法意味著，除了每個橫列的第一顆像素以外，其餘的像素我們其實可以不用跑這麼多次的迴圈，可以用單純的運算去求到值。

如此一來就又少了一大票`需運行迴圈次數`～ 

# 小結 

我們這次介紹了方框模糊的`理論`與`簡化理論的辦法`，明天我們將會繼續來到`實作`的部分~ 敬請各位期待 :D





